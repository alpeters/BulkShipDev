---
title: "ML FC Domain Comparison"
format: html
editor: visual
---

```{r}
library(tidyverse)
# library(kableExtra)
library(readr)
```

# Global params

```{r}
imagepath = "plots"
tablepath = "tables"
mltrackeddatapath = "tracked_data"
trackeddatapath = "../src/tracked_data"
fileprefix = "ML_FC_Domain_Comparison_"

# update_geom_defaults("text", list(size = 20))
base_size <- 18
theme_set(theme_minimal(base_size = base_size))
theme_pres <- function(base_size){
  theme_get() %+replace%
    theme(axis.ticks = element_line(colour = "grey70", linewidth = rel(0.5)),
          panel.grid = element_blank(),
          panel.grid.major.y = element_line(colour = 'grey90', linewidth = rel(0.5)),
          # panel.border = element_rect(fill = NA, colour = "grey30", linewidth = rel(0.8)),
          strip.text = element_text(size=1.03*base_size),
          legend.text = element_text(size=1.1*base_size))
}
pres_palette <- c("#482677FF", "#1D7C5A", "#A64902", "#e7298a")
```

```{r}
split_feature <- 'dwt' #'relseaspeed' #
sets <- c('djdrank4', 'speeddist', 'djdrank10', 'oecd')
# sets <- c('djdrank4', 'speeddist', 'work', 'djdrank10') #, 'oecd')
metric_table <- tibble()

for(set in sets){
  # read csv file for each quartile test set
  for(quart in 1:4){
    df <- read_csv(file.path(mltrackeddatapath,
                             paste0("ML_FC_F",
                                    set,
                                    "_testquart",
                                    quart,
                                    split_feature,
                                    "_test_fc.csv")),
                   show_col_types = FALSE) |> 
      select(-params) |> 
      pivot_longer(-c(model, class_name), names_to = 'metric') |> 
      mutate(set = set,
             quartile = quart)
    metric_table <- bind_rows(metric_table, df)
  }
  
}

metric_table <- metric_table |> 
  mutate(set = factor(set,
                      levels = c('speeddist', 'djdrank4', 'work', 'oecd', 'djdrank10'),
                      labels = c('Speed & Distance', 'Calc Components', 'Work', 'OECD', 'Preferred'),
                      ordered = TRUE))
```

```{r}
best_stat_function <- function(stat, value){
  if(stat %in% c('mae', 'mape', 'rmse', 'ate')){
    return(min(value))
  }else if(stat %in% c('r2')){
    return(max(value))
  }
}
```

```{r}
stat_plot_best <- function(metric_table, stat, ylims = c(NA, NA)){
  
  stat_table <- metric_table |> 
    filter(metric == stat)
  
  if(stat == 'te'){
    stat_table <- stat_table |>
      rename('te' = value) |>
      mutate(value = abs(te))
    stat <- 'ate'
  }
  
  stat_table <- stat_table |>
    group_by(set, quartile) |> 
    filter(value == best_stat_function(stat, value)) |> 
    ungroup() |> 
    select(set, quartile, value) 
    # pivot_wider(names_from = quartile, values_from = value, names_prefix = 'quart') %>%
    # mutate(mean = rowMeans(select(., starts_with('quart'))))
    
  stat_plot <- stat_table |> 
    ggplot(aes(x = quartile, y = value, fill = set)) +
    geom_col(position = 'dodge') +
    geom_hline(aes(yintercept = mean, color = set),
               linetype = 'dashed',
               data = stat_table |> group_by(set) |> summarise(mean = mean(value))) +
    scale_fill_manual(values = pres_palette) +
    scale_color_manual(values = pres_palette) +
    theme_pres(base_size) +
    labs(y = str_to_upper(stat),
         x = 'Test quartile',
         fill = 'Feature set',
         color = 'Feature set') +
    coord_cartesian(ylim = ylims)
  # display plot
  return(stat_plot)
}
```

```{r}
stat_plot_model <- function(metric_table, stat, plotmodel, ylims = c(NA, NA)){
  
  stat_table <- metric_table |> 
    filter(metric == stat)
    
  if(stat == 'te'){
    stat_table <- stat_table |>
      rename('te' = value) |>
      mutate(value = abs(te))
    stat <- 'ate'
  }
  
  stat_table <- stat_table |>
    filter(model == plotmodel) |>  
    select(model, set, quartile, value)
    
  stat_plot <- stat_table |> 
    ggplot(aes(x = quartile, y = value, fill = set)) +
    geom_col(position = 'dodge') +
    geom_hline(aes(yintercept = mean, color = set),
               linetype = 'dashed',
               data = stat_table |> group_by(set) |> summarise(mean = mean(value))) +
    scale_fill_manual(values = pres_palette) +
    scale_color_manual(values = pres_palette) +
    theme_pres(base_size) +
    labs(y = str_to_upper(stat),
         x = 'Test quartile',
         fill = 'Feature set',
         color = 'Feature set',
         title = plotmodel) +
    coord_cartesian(ylim = ylims)
  # display plot
  return(stat_plot)
}
```

# Best model performance by test quartile

```{r}
stat_plot_best(metric_table, 'mape') |> print()
```

```{r}
stat_plot_best(metric_table, 'mae') |> print()
```

```{r}
stat_plot_best(metric_table, 'r2', ylims = c(0.8, 1)) |> print()
```

```{r}
stat_plot_best(metric_table, 'te') |> print()
```

# Model Performance by test quartile

## Calculation

```{r}
stat_plot_model(metric_table, 'mape', 'eng') |> print()
```

```{r}
stat_plot_model(metric_table, 'mae', 'eng') |> print()
```

## Gradient Boost

```{r}
stat_plot_model(metric_table, 'mape', 'gb') |> print()
```

## Ridge

```{r}
stat_plot_model(metric_table, 'mape', 'ridge') |> print()
```

## All models

```{r}
stat <- 'mape'

stat_table <- metric_table |> 
    filter(metric == stat)
    
  if(stat == 'te'){
    stat_table <- stat_table |>
      rename('te' = value) |>
      mutate(value = abs(te))
    stat <- 'ate'
  }
  
  stat_table |> 
    ggplot(aes(x = quartile, y = value, fill = set)) +
    geom_col(position = 'dodge') +
    geom_hline(aes(yintercept = mean, color = set),
               linetype = 'dashed',
               data = stat_table |> group_by(set, model) |> summarise(mean = mean(value), .groups = 'drop')) +
    scale_fill_manual(values = pres_palette) +
    scale_color_manual(values = pres_palette) +
    theme_pres(base_size) +
    labs(y = str_to_upper(stat),
         x = 'Test quartile',
         fill = 'Feature set',
         color = 'Feature set') +
    facet_wrap(~model)
```

# Average performance across feature sets

```{r}
stat <- 'mape'

metric_table |> 
  filter(metric == stat) |> 
  group_by(model, class_name, set, metric) |> 
  summarise(value = mean(value), .groups = 'drop') |> 
  pivot_wider(names_from = set, values_from = value) |>
  select(-metric, -model) |> 
  arrange(class_name)

metric_table |> 
  filter(metric == stat) |> 
  group_by(model, class_name, set, metric) |> 
  summarise(value = sd(value), .groups = 'drop') |> 
  pivot_wider(names_from = set, values_from = value) |>
  select(-metric, -model) |> 
  arrange(class_name)

metric_table |> 
  filter(metric == stat) |> 
  group_by(model, class_name, set, metric) |> 
  summarise(value = sd(value)/mean(value), .groups = 'drop') |> 
  pivot_wider(names_from = set, values_from = value) |>
  select(-metric, -model) |> 
  arrange(class_name)
```
